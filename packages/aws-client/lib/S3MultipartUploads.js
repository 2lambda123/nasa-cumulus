// Utility functions to help with S3 multi-part uploads

'use strict';

const range = require('lodash/range');
const { s3 } = require('../services');

const GB = 1024 * 1024 * 1024;

// Each part of a multi-part copy needs to specify a byte range to be copied.
// This byte range has a starting byte and an ending byte (inclusive) that makes
// up the part. All parts must be larger than 5 MB, except that the last part
// may be smaller than 5 MB. Parts cannot be larger than 5 GB.
//
// This function takes a file size and an optional maxSize. It returns an array
// of objects, each containing a `start` and an `end` value. These will make up
// the ranges of the multi-part copy.
//
// https://docs.aws.amazon.com/AmazonS3/latest/API/API_UploadPartCopy.html
const createMultipartChunks = (size, maxSize = 5 * GB) => {
  const lastChunkSize = size % maxSize;

  // Build the list of full-size chunks
  const chunks = range(0, size - lastChunkSize, maxSize).map((start) => {
    const end = start + maxSize - 1;
    return { start, end };
  });

  // If necessary build the last, not-full-size chunk
  if (lastChunkSize !== 0) {
    const start = size - lastChunkSize;
    const end = size - 1;
    chunks.push({ start, end });
  }

  return chunks;
};

const createMultipartUpload = async (params) => {
  const response = await s3().createMultipartUpload(params).promise();
  return response.UploadId;
};

const completeMultipartUpload = async (params) => {
  await s3().completeMultipartUpload(params).promise();
};

const abortMultipartUpload = (params) =>
  s3().abortMultipartUpload(params).promise();

// This performs an S3 `uploadPartCopy` call. That response includes an `ETag`
// value specific to the part that was uploaded. When `completeMultipartUpload`
// is called later, it needs that `ETag` value, as well as the `PartNumber` for
// each part. Since the `PartNumber` is not included in the `uploadPartCopy`
// response, we are adding it here to make our lives easier when we eventually
// call `completeMultipartUpload`.
const uploadPartCopy = async (params) => {
  const response = await s3().uploadPartCopy(params).promise();

  return {
    ...response,
    PartNumber: params.PartNumber
  };
};

// Given a list of chunks (as generated by `createMultipartChunks`), create the
// list of params that will be passed to each invocation of the `uploadPartCopy`
// function.
const buildUploadPartCopyParams = ({
  chunks,
  destinationBucket,
  destinationKey,
  sourceBucket,
  sourceKey,
  uploadId
}) =>
  chunks.map(({ start, end }, index) => ({
    UploadId: uploadId,
    Bucket: destinationBucket,
    Key: destinationKey,
    PartNumber: index + 1,
    CopySource: `/${sourceBucket}/${sourceKey}`,
    CopySourceRange: `bytes=${start}-${end}`
  }));

// Generate the params that will be passed to the `completeMultipartUpload`
// function
const buildCompleteMultipartUploadParams = ({
  destinationBucket,
  destinationKey,
  uploadId,
  uploadPartCopyResponses
}) => ({
  UploadId: uploadId,
  Bucket: destinationBucket,
  Key: destinationKey,
  MultipartUpload: {
    Parts: uploadPartCopyResponses.map(
      (response) => ({
        PartNumber: response.PartNumber,
        ETag: response.CopyPartResult.ETag
      })
    )
  }
});

module.exports = {
  abortMultipartUpload,
  buildCompleteMultipartUploadParams,
  buildUploadPartCopyParams,
  completeMultipartUpload,
  createMultipartChunks,
  createMultipartUpload,
  uploadPartCopy
};
