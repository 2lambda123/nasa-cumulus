// Utility functions to help with S3 multi-part uploads

import range from 'lodash/range';
import { s3 } from '../services';

type Chunk = {
  start: number,
  end: number
};

const MB = 1024 * 1024;
const GB = 1024 * MB;

// Each part of a multi-part copy needs to specify a byte range to be copied.
// This byte range has a starting byte and an ending byte (inclusive) that makes
// up the part. The maximum allowed chunk size is 5368709120 bytes.
//
// This function takes a file size and an optional maxSize. It returns an array
// of objects, each containing a `start` and an `end` value. These will make up
// the ranges of the multi-part copy.
//
// From anecdotal testing, a chunk size of 250 MB seems to perform fairly well.
//
// https://docs.aws.amazon.com/AmazonS3/latest/API/API_UploadPartCopy.html
export const createMultipartChunks = (
  objectSize: number,
  maxChunkSize = 250 * MB
): Chunk[] => {
  if (maxChunkSize > (5 * GB)) {
    throw new Error('maxChunkSize can be no greater than 5368709120');
  }

  const lastChunkSize = objectSize % maxChunkSize;

  // Build the list of full-size chunks
  const chunks = range(0, objectSize - lastChunkSize, maxChunkSize)
    .map((start) => {
      const end = start + maxChunkSize - 1;
      return { start, end };
    });

  // If necessary build the last, not-full-size chunk
  if (lastChunkSize !== 0) {
    const start = objectSize - lastChunkSize;
    const end = objectSize - 1;
    chunks.push({ start, end });
  }

  return chunks;
};

export const createMultipartUpload = async (
  params: AWS.S3.CreateMultipartUploadRequest
) => {
  const response = await s3().createMultipartUpload(params).promise();
  return response.UploadId;
};

export const completeMultipartUpload = (
  params: AWS.S3.CompleteMultipartUploadRequest
) => s3().completeMultipartUpload(params).promise();

export const abortMultipartUpload = (
  params: AWS.S3.AbortMultipartUploadRequest
) => s3().abortMultipartUpload(params).promise();

// This performs an S3 `uploadPartCopy` call. That response includes an `ETag`
// value specific to the part that was uploaded. When `completeMultipartUpload`
// is called later, it needs that `ETag` value, as well as the `PartNumber` for
// each part. Since the `PartNumber` is not included in the `uploadPartCopy`
// response, we are adding it here to make our lives easier when we eventually
// call `completeMultipartUpload`.
export const uploadPartCopy = async (params: AWS.S3.UploadPartCopyRequest) => {
  const response = await s3().uploadPartCopy(params).promise();

  return {
    ...response,
    PartNumber: params.PartNumber
  };
};

// Given a list of chunks (as generated by `createMultipartChunks`), create the
// list of params that will be passed to each invocation of the `uploadPartCopy`
// function.
export const buildUploadPartCopyParams = (
  params: {
    chunks: Chunk[],
    destinationBucket: string,
    destinationKey: string,
    sourceBucket: string,
    sourceKey: string,
    uploadId: string
  }
): AWS.S3.UploadPartCopyRequest[] => {
  const {
    chunks,
    destinationBucket,
    destinationKey,
    sourceBucket,
    sourceKey,
    uploadId
  } = params;

  return chunks.map(({ start, end }, index) => ({
    UploadId: uploadId,
    Bucket: destinationBucket,
    Key: destinationKey,
    PartNumber: index + 1,
    CopySource: `/${sourceBucket}/${sourceKey}`,
    CopySourceRange: `bytes=${start}-${end}`
  }));
};

// Generate the params that will be passed to the `completeMultipartUpload`
// function
export const buildCompleteMultipartUploadParams = (
  params: {
    destinationBucket: string,
    destinationKey: string,
    uploadId: string,
    uploadPartCopyResponses: (AWS.S3.UploadPartCopyOutput & { PartNumber: number })[]
  }
): AWS.S3.CompleteMultipartUploadRequest => {
  const {
    destinationBucket,
    destinationKey,
    uploadId,
    uploadPartCopyResponses
  } = params;

  return {
    UploadId: uploadId,
    Bucket: destinationBucket,
    Key: destinationKey,
    MultipartUpload: {
      Parts: uploadPartCopyResponses.map(
        (response) => {
          if (response.CopyPartResult === undefined) {
            throw new Error(`Unable to determine ETag from: ${JSON.stringify(response)}`);
          }

          return {
            PartNumber: response.PartNumber,
            ETag: response.CopyPartResult.ETag
          };
        }
      )
    }
  };
};
